# الگوهای طراحی شئ‌گرا و بازآرایی کد (Object Oriented Design Patterns and Code Refactoring)
## اعضای گروه: سپهر حرفی - زهرا علیپور - محمدمهدی واحدی

## فاز اول
برای طراحی برنامه، ما اول کلاس main را به پوشه graph اضافه کردیم و آنرا پیاده‌سازی کردیم تا بتواند ورودی را از کاربر دریافت کند و در ابتدا یک پاسخ بدیهی به آن بدهد تا بعدا متدهای لازم پیاده سازی شوند. پس از آن به سراغ طراحی سه دستور اول رفتیم که در آن از الگوی state استفاده کردیم. در ابتدا یک interface با نام [state](Pattern/src/main/java/graph/State.java) ایجاد کردیم متدهای لازم برای سه دستور اول را در آن قرار دادیم. پس از آن دو کلاس با نام ‌های OneWayState و TwoWayState را که از کلاس state ارث‌بری می‌کنند را پیاده‌سازی کردیم بدون اینکه متدهای داخل آنرا پیاده سازی کنیم. در نهایت برای مدیریت راه ها یک کلاس RoadControl ایجاد کردیم که دارای یک متغیر state است که می‌تواند بین دو حالت یک طرف و دو طرفه تغییر کند. این کلاس بدون در نظر گرفتن نوع state توابع آن را فراخونی خواهد کرد و بدین شکل از الگو state استفاده می‌کنیم. در نهایت پس از ایجاد متدهای لازم با بدنه خالی، تست‌های لازم را در فایل StateTest ایجاد می‌کنیم و مرحله به مرحله با روش TDD متدهای لازم را پیاده‌سازی می‌کنیم. 


## فاز دوم
### الگوی Facade 
دو کلاس CodeGenerator و Parser را بازآرایی میکنیم. کلاس CodeGenerator چون محتوای پیچیده و زیادی دارد گزینه خوبی است. این کلاس در parser استفاده شده است و فقط دو فانکشن آن استفاده شده است. پس کلاس CodeGeneratorFacade را میسازیم. همچنین موردهای استفاده‌ی SemanticFunction توسط خود کلاسش است و استفاده خارجی نیست که از Facade استفاده کنیم. برای Parser، در Main استفاده میشود و مانند تغییر قبلی کلاس ParserFacade را میسازیم.

### الگوی Polymorphism
برای این تغییر در CodeGenerator یک سوییچ طولانی  را با تعریف یک کلاس abstract حذف می‌کنیم و بعد با استفاده از کلاس خود و کلاس‌های زیر مجموعه  کار را جلو ببریم.

### الگوی Seperate Query From Modifier
منودهای getTemp و getDataAddress در کلاس مموری هم تغییر دارند وهم ریترن ادرس که می‌توانیم با آوردن دو متود برای تغییر به صورت جداگانه این مشکل را حل کنیم.

### الگوی Self Encapsulated Field 

کلاس LexicalAnalyzer یک تغییر انجام دادیم که matcher که یک فیلد پرایوت است را با setter و getter بتوان تغییر داد و نه به صورت مستقیم. پس از الگوی Self Encapsulated Field استفاده کردیم.

## پرسش‌ها

### سوال اول 

در کتاب GoF به سه الگوی طراحی Creational Pattern, Strcutural Pattern, Behavioral Pattern اشاره شده است که در ادامه توضیح مختصری از هر یک آورده شده است:

Structural Pattern: با استفاده از این الگو کلاس‌ها و اشیا ترکیب شده و ساختارهای بزرگ‌‌تر پیچیده‌تر ساخته می‌شوند. 

Cretional Pattern: هدف این الگو این است که فرایند ساخت اشیا مستقل از کلاینت باشد. 

Behavioral Pattern: این الگو مدیریت کردن بین اشیا و روابط و مسئولیت‌هایی که دارند استفاده می‌شود. 

### سوال دوم 
با توجه به اینکه الگوهای های استفاده شده Strategy و State هستند و توصیف رفتار اشیار و گذاشتن محدودیت برای آن‌ها را تعیین می‌کنند پس در واقع هر دو بخشی از الگو‌های behavioural هستند.  

### سوال سوم 
 با توجه به اینکه تنها یک درخواست مشخص در هر اجرا داریم پس از الگویی که در آن یک کلاس داریم و تنها یک شی از آن کلاس وجود دارد میتوانیم استفاده کنیم و میتوان از همان الگوی طراحی Singleton استفاده کرد که به خواسته‌ی تک شی بودن توجه شود. 
 
### سوال چهارم 

### در اینجا به بررسی الگو خود در اصول مختلف میپردازیم:
### Single Responsibility : این مورد میتوان گفت در این الگوی طراحی ممکن است نقض شود زیرا علاوه بر وظیقه اصلی که کمنرل کردن ایجاد درست و یکدانه ای شی است. وظیقه مدیریت حالت آن این نیز با این الگو است.
### OCP: این الگو این اصل را به طور کامل رعایت میکند به این علت که واضحا بر روی تغییرات بسته است ولی بر روی تویعه ادند و پیشرفت کردن این  مورد به هیچ عنوان بسته نیست بلکه باز هم هست..
### Liskov Substitiution: این الگو تنها در یک صورت ممکن است این اصل را نقض کند. آن هم این حالت است که ابتدا از وراثت اسفتاده گردد و علاوه بر آن زیر کلاس ها جایگزین نشوند.
### ISP: به  این علت که این الگوی طراحی به طور معمول نیازی به پیاده سازی چندین رابطه ای ندارد پس این الگو  به طور عمومی و اکثر اوقات قضیه را رعایت میکند.
### DIP:ممکن است چون وابستگی های ما به طور مستقیم و بی واسطه به خود کلاس این الگو اشاره دارد پس میتوان گفت که این الگو به طو کلی میتواند این اصل را نقض کند.

### سوال پنجم
کد تمیز: کدی است که ساده، خوانا، قابل فهم و به‌راحتی قابل نگهداری باشد و اصول و بهترین شیوه‌های برنامه‌نویسی را رعایت کند.

بدهی فنی: زمانی که به‌جای انتخاب راه‌حل‌های بهینه، راه‌حل‌های ساده‌تر و کم‌کیفیت‌تری انتخاب می‌شود، در نتیجه این تصمیم‌ها، در آینده نیاز به هزینه و زمان بیشتری برای اصلاح و بهبود پیش می‌آید.

بوی بد: بخش‌های مشکل‌دار در کد که می‌تواند در آینده به مشکلات پیچیده‌تر و بزرگ‌تری منجر شود، مانند تکرار کد، پیچیدگی بیش از حد و نام‌گذاری‌های نامناسب.

### سوال ششم 
### انواع بوهای بد در کد

1. **بوهای بد کلی**: این دسته شامل مشکلاتی است که می‌توانند در هر بخش از کد رخ دهند، مانند تکرار کد، توابع طولانی و پیچیدگی بیش از حد.

2. **بوهای بد در کلاس‌ها**: این دسته شامل مشکلات مرتبط با طراحی و ساختار کلاس‌ها می‌باشد، مانند کلاس‌های بزرگ و کلاس‌های داده‌ای که تنها شامل داده‌ها هستند و منطق خاصی ندارند.

3. **بوهای بد در شیوه‌های تعاملی بین اشیاء**: این دسته شامل مشکلاتی است که در نحوه تعامل و ارتباط بین اشیاء رخ می‌دهد، مانند وابستگی‌های زیاد و تعاملات غیرضروری بین کلاس‌ها.

4. **بوهای بد در استفاده از ارث‌بری**: این دسته شامل مشکلاتی است که به استفاده نادرست یا بیش از حد از ارث‌بری مرتبط می‌شود، مانند سلسله‌مراتب ارث‌بری عمیق و فرزندان نامناسب.

5. **بوهای بد مرتبط با تغییرپذیری**: این دسته شامل مشکلاتی است که تغییرات را دشوار و پرهزینه می‌کند، مانند متغیرهای سراسری و اثرات جانبی غیرمنتظره در کد.



### سوال هفتم 
- بوی بد Lazy Class در دسته‌بندی "بوهای بد در کلاس‌ها" قرار دارد.

- برای برطرف کردن Lazy Class، از بازآرایی‌های Inline Class و Collapse Hierarchy استفاده می‌شود.

- این بو را می‌توان در صورتی نادیده گرفت که کلاس به‌عنوان یک Extension Point طراحی شده باشد یا برنامه‌ای برای توسعه آن در آینده وجود داشته باشد.

### سوال هشتم 
### ۱) Main.java
- بوی **Long Method**: متد `generateInfoForXML` بسیار طولانی است و مسئولیت‌های زیادی دارد که این باعث کاهش خوانایی و نگهداری کد می‌شود.
- بوی **Large Class**: کلاس `Main` شامل چندین متغیر استاتیک و متدهای مختلف است که مسئولیت‌های زیادی بر عهده دارد. این کلاس بیش از حد بزرگ شده است و می‌تواند به چندین کلاس کوچکتر تقسیم شود تا خوانایی و نگهداری بهبود یابد.
- بوی **Primitive Obsession**: استفاده از انواع داده‌های ابتدایی مانند `String` برای مقادیر خاص (مانند `fileName`) به جای استفاده از اشیاء مناسب می‌تواند مشکلاتی را ایجاد کند و خوانایی کد را کاهش دهد.

### ۲) Phase1CodeGenerator.java
- بوی **Long Method**: متد سازنده `Phase1CodeGenerator` بسیار طولانی است و مسئولیت‌های زیادی دارد که این باعث کاهش خوانایی و نگهداری کد می‌شود.
- بوی **Feature Envy**: متدهای موجود در این کلاس به نظر می‌رسد که بیش از حد به داده‌های کلاس `CompleteDiagram` دسترسی دارند. این نشان می‌دهد که بخشی از منطق می‌تواند به کلاس `CompleteDiagram` منتقل شود.
- بوی **Primitive Obsession**: استفاده از انواع داده‌های ابتدایی مانند `String` برای مقادیر خاص (مانند نام فایل‌ها) به جای استفاده از اشیاء مناسب می‌تواند مشکلاتی را ایجاد کند و خوانایی کد را کاهش دهد.

### ۳) Phase2CodeFileManipulator.java
- بوی **Data Clumps**: وجود فیلدهای متعددی مانند `numberOfClassCalled`، `numberOfStructureKeywordCalled`، `numberOfClassKeywordCalled` و غیره که همیشه با هم استفاده می‌شوند، نشان دهنده وجود توده‌های داده‌ای (Data Clumps) است. این فیلدها می‌توانند به یک شیء مشترک تبدیل شوند.
- بوی **Feature Envy**: برخی از متدها به نظر می‌رسد که بیش از حد به داده‌های کلاس `DiagramInfo` دسترسی دارند. این نشان می‌دهد که بخشی از منطق می‌تواند به کلاس `DiagramInfo` منتقل شود.
- بوی **Temporary Field**: فیلد `writer` که فقط در برخی از شرایط خاص مقداردهی می‌شود و در سایر مواقع بلااستفاده است. این فیلد موقت می‌تواند به جای فیلد کلاس، به یک متغیر محلی در متدها تبدیل شود.

### ۴) LexicalAnalyzer.java
- بوی **Speculative Generality**: وجود متدهای عمومی و واسط‌هایی که ممکن است برای استفاده‌های آینده تعریف شده باشند ولی در حال حاضر مورد استفاده قرار نگرفته‌اند. این باعث پیچیدگی و افزایش اندازه کد بدون دلیل موجه می‌شود. برای مثال، متدهای `deleteClassSpecifier` و `deleteTypeQualifier` که به نظر می‌رسد برای حالت‌های خاص تعریف شده‌اند ولی ممکن است به طور کامل مورد نیاز نباشند.

### سوال نهم 


پلاگین formatter-maven-plugin کمک می‌کند تا کدهای جاوا را با استفاده از Eclipse قالب‌بندی کنیم. این ابزار با اعمال قالب‌بندی اتوماتیک بر روی کدها، به خوانایی کد کمک می‌کند. رابطه آن با بازآرایی کد در این است که با اعمال قالب‌بندی صحیح و رعایت استانداردهای کدنویسی، از بروز برخی بوهای بد کد جلوگیری کرده و کد را تمیز و منظم نگه می‌دارد، که باعث کاهش بدهی فنی و افزایش کیفیت کلی کد می‌شود.
 
